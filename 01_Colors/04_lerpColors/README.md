# Color_04_colorLinearInterpolation


## Step 1

```js

//Specify the width and height of our canvas
let width = 750;
let height = 750;

//creating two arrays to hold the lefthand and the righthand colors
let colorsRight = [];
let colorsLeft = [];

//specify the amount of boxes in the X and Y direction
let tileCountX = 10;
let tileCountY = 10;

function setup(){
  createCanvas(width,height);
  colorMode(HSB);
  noStroke();

  //calls the shakeColors fucntion
  shakeColors();
}

function draw(){

}

//populates the color arrays with random colors
function shakeColors() {
  //for as many boxes there are in the Y direction
  for(let i = 0; i<tileCountY; i++){
    //add a new color generated by the genRandom function
    colorsLeft.push(genRandomCol());
  }
  for(let i = 0; i<tileCountY; i++){
    //add a new color generated by the genRandom function
    colorsRight.push(genRandomCol());
  }
}

//generates 3 random values for R, G and B and creates a color object with them
function genRandomCol(){
  let col1 = floor(random(0,255));
  let col2 = floor(random(0,255));
  let col3 = floor(random(0,255));
  let randomColor = color(col1,col2,col3);
  //return the color object that was created
  return randomColor;
}

```

## Step 2

```js

boxWidth = width / tileCountX;
boxHeight = height / tileCountY;
for (let y = 0; y <= tileCountY; y++) {
  // assign the colors to lerp between from the color arrays
  let startCol = colorsLeft[y];
  let endCol = colorsRight[y];
  //for each column in the row...
  for (let x = 0; x <= tileCountX; x++) {
    //define the tile position
    let posX = x * boxWidth;
    let posY = y * boxHeight;
    // render the tile
    rect(posX, posY, boxWidth, boxWidth);
  }
}

```

## Step 3

```js
boxWidth = width / tileCountX;
boxHeight = height / tileCountY;
// loop through the rows and popluate them with color
// for each row...
for (let y = 0; y <= tileCountY; y++) {
  // assign the colors to lerp between from the color arrays
  let startCol = colorsLeft[y];
  let endCol = colorsRight[y];
  //for each column in the row...
  for (let x = 0; x <= tileCountX; x++) {
    //establish the amount the current tile's color should be lerped by
    let lerpAmount = map(x, 0, tileCountX - 1, 0, 1);
    //lerp between startCol and endCol by the specified amount
    let interColor = lerpColor(startCol, endCol, lerpAmount);
    // set the fill
    fill(interColor);
    //define the tile position
    let posX = x * boxWidth;
    let posY = y * boxHeight;
    // render the tile
    rect(posX, posY, boxWidth, boxWidth);
  }
}

```

## Step 4

```js
//add in a variable to control the method of interpoltion
var interpolateShortest = true;
```

```js
//based on that interpolation variable...
if (interpolateShortest) {
  // switch to rgb color mode
  colorMode(RGB);
  interColor = lerpColor(startCol, endCol, lerpAmount);
  // switch back to HSB
  colorMode(HSB);
} else {
  interColor = lerpColor(startCol, endCol, lerpAmount);
}
```

```js
function keyPressed() {
  //add in the keypressed functionality to...
  // export color array as an ASE file
  if (key == 'c' || key == 'C') writeFile([gd.ase.encode(colors)], gd.timestamp(), 'ase');
  //save canvas as a PNG
  if (key == 's' || key == 'S') saveCanvas(gd.timestamp(), 'png');
  //alter the interpolation variable using keyPressed
  if (key == '1') interpolateShortest = true;
  if (key == '2') interpolateShortest = false;
}
```

```js
// add in mouse interaction to generate a new color palette
function mouseReleased(){
  shakeColors();
}
```
